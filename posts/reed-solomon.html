<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How Your Data Survives Corruption — ◯</title>
  <script>
    // Blocking theme initialization - runs before CSS to prevent flash
    (function() {
      const saved = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const theme = saved || (prefersDark ? 'dark' : 'light');
      document.documentElement.setAttribute('data-theme', theme);
    })();
  </script>
  <link rel="stylesheet" href="../style.css">
  <style>
    /* Demo box polish */
    .demo {
      position: relative;
      background: 
        linear-gradient(135deg, 
          rgba(var(--demo-glow), 0.03) 0%, 
          transparent 50%,
          rgba(var(--demo-glow), 0.02) 100%
        );
      box-shadow: 
        inset 0 1px 0 rgba(var(--demo-glow), 0.05),
        inset 0 -1px 0 rgba(var(--demo-glow), 0.02);
    }
    
    :root {
      --demo-glow: 0, 0, 0;
    }
    
    [data-theme="dark"] {
      --demo-glow: 255, 255, 255;
    }
    
    /* Corruption button styles */
    .corrupt-btn {
      width: 44px;
      height: 44px;
      font-size: 16px;
      font-family: 'JetBrains Mono', monospace;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      transition: all 0.15s ease;
      position: relative;
      overflow: hidden;
    }
    
    .corrupt-btn::before {
      content: '';
      position: absolute;
      inset: 0;
      background: var(--text);
      opacity: 0;
      transition: opacity 0.15s ease;
    }
    
    .corrupt-btn:hover::before {
      opacity: 0.05;
    }
    
    .corrupt-btn:active {
      transform: scale(0.96);
    }
    
    .corrupt-btn.data-point {
      background: var(--text);
      color: var(--bg);
    }
    
    .corrupt-btn.parity-point {
      background: var(--bg);
      color: var(--text);
    }
    
    .corrupt-btn.corrupted {
      animation: shake 0.4s ease;
      background: var(--bg) !important;
      color: var(--text) !important;
      border-color: var(--text);
    }
    
    .corrupt-btn.corrupted::after {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        45deg,
        transparent,
        transparent 2px,
        rgba(var(--demo-glow), 0.1) 2px,
        rgba(var(--demo-glow), 0.1) 4px
      );
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      20% { transform: translateX(-3px); }
      40% { transform: translateX(3px); }
      60% { transform: translateX(-2px); }
      80% { transform: translateX(2px); }
    }
    
    /* Pulse animation for recovery status */
    @keyframes pulse-border {
      0%, 100% { border-color: var(--border); }
      50% { border-color: var(--text); }
    }
    
    .status-recoverable {
      animation: pulse-border 1.5s ease infinite;
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <div class="logo"><a href="../index.html">◯</a></div>
      <nav>
        <a href="../about.html">about</a>
        <a href="../archive.html">archive</a>
        <a href="https://github.com/onoht">github</a>
      </nav>
      <button class="theme-toggle">◐</button>
    </div>
  </header>

  <main>
    <div class="container">
      <div class="post">
        <h1>How Your Data Survives Corruption</h1>
        <p class="date">2026-02-28 · error correction</p>

        <p>You scan a QR code. It's scratched, torn, partially covered by a sticker. Yet somehow, your phone reads it perfectly.</p>

        <p>You play a CD from 1995. It has visible scratches you can feel with your fingernail. The music plays flawlessly.</p>

        <p>Voyager 1 sent photos from beyond Saturn — through radiation, across billions of kilometers, with a transmitter weaker than a refrigerator light bulb. The images arrived intact.</p>

        <p>How? Reed-Solomon error correction — one of the most elegant ideas in computing. Let me show you how it works.</p>

        <h2>The Problem: Imperfect Channels</h2>

        <p>Data transmission is never perfect. Whether it's:</p>
        <ul>
          <li>Radio waves through atmosphere</li>
          <li>Lasers reading microscopic pits on plastic discs</li>
          <li>Cosmic rays flipping bits in memory</li>
          <li>Physical damage to storage media</li>
        </ul>

        <p>Errors are inevitable. The question is: how do we recover from them?</p>

        <div class="demo">
          <div class="demo-label">The Naive Approach</div>
          <p style="text-align: center; line-height: 2;">
            Send: <code>HELLO</code><br><br>
            Corruption: <code>HE�LO</code> (one character lost)<br><br>
            Result: Irrecoverable. The message is gone forever.
          </p>
        </div>

        <p>We need redundancy. But not just any redundancy — <em>smart</em> redundancy.</p>

        <h2>The Insight: Polynomial Fingerprints</h2>

        <p>Here's the key idea behind Reed-Solomon:</p>

        <p><strong>Any polynomial of degree n-1 is uniquely defined by n points.</strong></p>

        <p>Let's say you have a message with 4 symbols. You can fit a cubic polynomial (degree 3) through them. Now here's the magic: you can evaluate this polynomial at more points — say, 6 total — and now you have 2 extra "check" symbols.</p>

        <p>Even if you lose 2 symbols (any 2!), you can still reconstruct the original polynomial from the remaining 4. Which means you can recover your original message.</p>

        <div class="demo">
          <div class="demo-label">Interactive: Polynomial Interpolation</div>
          <div id="poly-demo">
            <p style="text-align: center; margin-bottom: 20px; font-size: 14px;">
              <strong>Original message:</strong> 4 data points (black)<br>
              <strong>Redundancy:</strong> 2 check points (white)
            </p>
            <canvas id="polyCanvas" width="500" height="250" style="display: block; margin: 0 auto; max-width: 100%;"></canvas>
            <p class="interactive-hint">Click on points to "corrupt" them. As long as 4 points remain, the polynomial can be reconstructed.</p>
          </div>
        </div>

        <p>This is the core of Reed-Solomon encoding: convert your message to polynomial coefficients, evaluate at multiple points, and you've built in redundancy that can survive corruption.</p>

        <h2>How QR Codes Use This</h2>

        <p>QR codes are brilliant because they make error correction visible. Let's see it in action.</p>

        <div class="demo">
          <div class="demo-label">Interactive: QR Code Error Correction</div>
          <div id="qr-demo">
            <div style="display: flex; gap: 30px; justify-content: center; align-items: start; flex-wrap: wrap; margin: 20px 0;">
              <div style="text-align: center;">
                <div style="font-size: 12px; margin-bottom: 8px;">Original Data</div>
                <div id="original-data" style="font-size: 16px; letter-spacing: 3px; padding: 12px; border: 1px solid var(--border);">
                  H E L L O
                </div>
              </div>
              <div style="font-size: 20px;">→</div>
              <div style="text-align: center;">
                <div style="font-size: 12px; margin-bottom: 8px;">With Redundancy (Level M)</div>
                <div id="encoded-data" style="font-size: 16px; letter-spacing: 3px; padding: 12px; border: 1px solid var(--border);">
                  H E L L O <span style="border: 1px solid var(--text); padding: 0 4px;">K R 7 X</span>
                </div>
              </div>
            </div>

            <div style="margin: 32px 0;">
              <label style="display: block; text-align: center; margin-bottom: 12px; font-size: 14px;">
                <strong>Corrupt symbols:</strong> (click to toggle)
              </label>
              <div id="corruption-buttons" style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;"></div>
            </div>

            <div style="margin-top: 24px; padding: 20px; border: 1px solid var(--border); transition: border-color 0.3s;" id="status-box">
              <p id="status" style="margin: 0; font-size: 14px;"></p>
            </div>
          </div>
          <p class="interactive-hint">Try corrupting up to 2 symbols. The message can still be recovered!</p>
        </div>

        <p>QR codes offer four error correction levels:</p>

        <table>
          <thead>
            <tr>
              <th>Level</th>
              <th>Recoverable</th>
              <th>Use Case</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>L</strong> (Low)</td>
              <td>~7%</td>
              <td>Maximum data capacity</td>
            </tr>
            <tr>
              <td><strong>M</strong> (Medium)</td>
              <td>~15%</td>
              <td>Standard QR codes</td>
            </tr>
            <tr>
              <td><strong>Q</strong> (Quartile)</td>
              <td>~25%</td>
              <td>Harsh environments</td>
            </tr>
            <tr>
              <td><strong>H</strong> (High)</td>
              <td>~30%</td>
              <td>Industrial, art (logos in QR)</td>
            </tr>
          </tbody>
        </table>

        <p>Level H is why you can put a logo in the middle of a QR code and it still works.</p>

        <h2>The Math (Simplified)</h2>

        <p>Reed-Solomon is specified as <strong>RS(n, k)</strong>:</p>
        <ul>
          <li><strong>k</strong> = number of data symbols</li>
          <li><strong>n</strong> = total symbols (data + parity)</li>
          <li><strong>n - k</strong> = parity symbols</li>
          <li><strong>t = (n - k) / 2</strong> = errors correctable</li>
        </ul>

        <p>Example: RS(255, 223) with 8-bit symbols:</p>
        <ul>
          <li>223 bytes of data</li>
          <li>32 bytes of parity</li>
          <li>Can correct errors in any 16 bytes</li>
        </ul>

        <div class="demo">
          <div class="demo-label">The Power of Reed-Solomon</div>
          <p style="text-align: center; font-size: 16px; line-height: 2;">
            RS(255, 223) can correct <strong>16 complete byte errors</strong><br>
            That's up to <strong>128 corrupted bits</strong><br>
            In <strong>any positions</strong> throughout the codeword
          </p>
        </div>

        <h2>Real-World Applications</h2>

        <h3>Compact Discs</h3>
        <p>CDs use <em>two</em> Reed-Solomon codes in sequence (CIRC — Cross-Interleaved Reed-Solomon Code). This combination can correct burst errors up to <strong>4000 bits</strong> — that's a scratch about 2.5mm long. Your CD player is constantly correcting errors you never notice.</p>

        <h3>Voyager Spacecraft</h3>
        <p>When Voyager 1 transmitted images from Saturn and Uranus, it used Reed-Solomon coding combined with convolutional codes. Signal-to-noise ratio was terrible. Bit error rates were high. But the images arrived intact.</p>

        <h3>Satellite Television</h3>
        <p>DVB (Digital Video Broadcasting) uses RS(204, 188). Every packet has 16 bytes of parity. Your TV picture doesn't glitch because Reed-Solomon is silently correcting transmission errors.</p>

        <h3>Data Storage</h3>
        <p>RAID systems, QR codes, barcodes, archival tapes — anywhere data must survive imperfect storage or transmission, Reed-Solomon is there.</p>

        <h2>Why Not Just Copy the Data?</h2>

        <p>You might wonder: why use fancy math? Why not just send each byte three times?</p>

        <p>Triple-redundancy works, but it's inefficient. To correct 16 errors in a 255-byte codeword using simple repetition, you'd need to send 48 extra copies of each byte (3× overhead for each of the 16 potentially bad bytes). Reed-Solomon does it with just 32 extra bytes total — <strong>~14% overhead</strong> instead of 3000%.</p>

        <div class="demo">
          <div class="demo-label">Efficiency Comparison</div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="text-align: center; padding: 20px; border: 1px solid var(--border);">
              <div style="font-weight: bold; margin-bottom: 10px;">Simple Repetition</div>
              <div style="font-size: 32px;">3000%</div>
              <div style="font-size: 12px; margin-top: 4px;">overhead</div>
            </div>
            <div style="text-align: center; padding: 20px; border: 1px solid var(--border);">
              <div style="font-weight: bold; margin-bottom: 10px;">Reed-Solomon</div>
              <div style="font-size: 32px;">14%</div>
              <div style="font-size: 12px; margin-top: 4px;">overhead</div>
            </div>
          </div>
          <p style="text-align: center; font-size: 12px;">
            For the same error-correction capability
          </p>
        </div>

        <h2>The Elegance</h2>

        <p>What I love about Reed-Solomon is how it transforms a problem (corruption) into geometry (polynomial curves). Your message becomes a shape. That shape can be evaluated at any point. Lose some points? The shape is still there, hiding in the remaining ones.</p>

        <p>It's like folding a paper crane — the original sheet is transformed, but the creases contain all the information needed to unfold it. Even if you tear off a corner, the remaining folds often contain enough to reconstruct the whole.</p>

        <div class="demo">
          <div class="demo-label">The Key Insight</div>
          <p style="text-align: center; font-size: 16px; line-height: 2;">
            Redundancy isn't about copying.<br>
            It's about <strong>structure</strong>.<br><br>
            A polynomial is more than its points —<br>
            it's the <strong>relationship</strong> between them.
          </p>
        </div>

        <h2>The Legacy</h2>

        <p>Reed-Solomon was invented in 1960 by Irving Reed and Gustave Solomon. Their original paper was just 4 pages. It's now one of the most widely used algorithms in history.</p>

        <p>Every time you:</p>
        <ul>
          <li>Scan a QR code with your phone</li>
          <li>Watch satellite TV</li>
          <li>Play a music CD</li>
          <li>Stream video over imperfect networks</li>
          <li>Store data on a hard drive</li>
        </ul>

        <p>Reed-Solomon is working silently in the background, correcting errors you never knew existed.</p>

        <p>Next time you see a scratched CD play perfectly, or a damaged QR code scan successfully, remember: a 60-year-old mathematical idea is making it possible.</p>

        <p class="further-reading">
          <strong>Further reading:</strong> 
          <a href="https://tomverbeure.github.io/2022/08/07/Reed-Solomon.html">Reed-Solomon from the Bottom Up</a> · 
          <a href="https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders">Reed-Solomon for Coders</a> ·
          <a href="https://www.cs.cmu.edu/~guyb/realworld/reedsolomon/reed_solomon_codes.html">CMU Introduction to RS Codes</a>
        </p>
      </div>
    </div>
  </main>

  <footer>
    <div class="container">
      <div class="symbol">◯</div>
      <div>one. no one. one hundred thousand.</div>
    </div>
  </footer>

  <script src="../theme-toggle.js"></script>
  <script>
    // Polynomial demo with smooth animations
    const canvas = document.getElementById('polyCanvas');
    const ctx = canvas.getContext('2d');
    
    // Enable high DPI rendering
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    
    const dataPoints = [
      {x: 1, y: 2, label: 'A', corrupted: false, opacity: 1},
      {x: 2, y: 5, label: 'B', corrupted: false, opacity: 1},
      {x: 3, y: 3, label: 'C', corrupted: false, opacity: 1},
      {x: 4, y: 7, label: 'D', corrupted: false, opacity: 1},
    ];
    
    const checkPoints = [
      {x: 5, y: 4, label: 'P1', corrupted: false, opacity: 1},
      {x: 6, y: 6, label: 'P2', corrupted: false, opacity: 1},
    ];
    
    let curveProgress = 1;
    let animationFrame = null;

    function getComputedStyleVar(varName) {
      return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    }

    function drawGrid() {
      const borderColor = getComputedStyleVar('--border');
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      
      // Draw subtle grid pattern
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 0.3;
      
      for (let i = 0; i <= 7; i++) {
        const x = 50 + i * 60;
        ctx.beginPath();
        ctx.moveTo(x, 20);
        ctx.lineTo(x, 230);
        ctx.stroke();
      }
      
      for (let j = 0; j <= 8; j++) {
        const y = 20 + j * 26.25;
        ctx.beginPath();
        ctx.moveTo(50, y);
        ctx.lineTo(410, y);
        ctx.stroke();
      }
      
      // Subtle dot pattern at intersections
      ctx.fillStyle = isDark ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.03)';
      for (let i = 0; i <= 7; i++) {
        for (let j = 0; j <= 8; j++) {
          const x = 50 + i * 60;
          const y = 20 + j * 26.25;
          ctx.beginPath();
          ctx.arc(x, y, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    function interpolatePolynomial(points, x) {
      // Simple polynomial interpolation for smooth curve
      let result = 0;
      const n = points.length;
      
      for (let i = 0; i < n; i++) {
        let term = points[i].y;
        for (let j = 0; j < n; j++) {
          if (i !== j) {
            term *= (x - points[j].x) / (points[i].x - points[j].x);
          }
        }
        result += term;
      }
      return result;
    }

    function drawCurve(progress) {
      const textColor = getComputedStyleVar('--text');
      const allPoints = [...dataPoints, ...checkPoints].filter(p => !p.corrupted);
      
      if (allPoints.length >= 4) {
        ctx.strokeStyle = textColor;
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        const startX = 50;
        const endX = 50 + 6 * 60 * progress;
        
        ctx.beginPath();
        let first = true;
        
        for (let px = startX; px <= endX; px += 2) {
          const x = (px - 50) / 60;
          const y = interpolatePolynomial(allPoints, x);
          const canvasY = 230 - y * 25;
          
          if (first) {
            ctx.moveTo(px, canvasY);
            first = false;
          } else {
            ctx.lineTo(px, canvasY);
          }
        }
        ctx.stroke();
      }
    }

    function drawPoints() {
      const textColor = getComputedStyleVar('--text');
      const bgColor = getComputedStyleVar('--bg');
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      
      [...dataPoints, ...checkPoints].forEach((point, idx) => {
        const x = 50 + point.x * 60;
        const y = 230 - point.y * 25;
        const opacity = point.opacity;
        
        ctx.globalAlpha = opacity;
        
        // Glow effect for active points
        if (!point.corrupted && opacity > 0.5) {
          const gradient = ctx.createRadialGradient(x, y, 0, x, y, 20);
          gradient.addColorStop(0, isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.08)');
          gradient.addColorStop(1, 'transparent');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(x, y, 20, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2);
        
        if (point.corrupted) {
          // Corrupted point - hollow with X
          ctx.fillStyle = bgColor;
          ctx.fill();
          ctx.strokeStyle = textColor;
          ctx.lineWidth = 1.5;
          ctx.setLineDash([3, 3]);
          ctx.stroke();
          ctx.setLineDash([]);
          
          ctx.fillStyle = textColor;
          ctx.font = '12px JetBrains Mono, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('✗', x, y);
        } else {
          // Active point
          const isDataPoint = idx < 4;
          ctx.fillStyle = isDataPoint ? textColor : bgColor;
          ctx.fill();
          ctx.strokeStyle = textColor;
          ctx.lineWidth = isDataPoint ? 0 : 2;
          if (!isDataPoint) ctx.stroke();
          
          ctx.fillStyle = isDataPoint ? bgColor : textColor;
          ctx.font = 'bold 10px JetBrains Mono, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(point.label, x, y + 1);
        }
        
        ctx.globalAlpha = 1;
      });
    }

    function drawGraph() {
      const bgColor = getComputedStyleVar('--bg');
      
      ctx.clearRect(0, 0, rect.width, rect.height);
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, rect.width, rect.height);
      
      drawGrid();
      drawCurve(curveProgress);
      drawPoints();
    }

    function animateCurve() {
      curveProgress = 0;
      const startTime = performance.now();
      const duration = 350;
      
      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        curveProgress = Math.min(1, elapsed / duration);
        
        // Ease out cubic
        curveProgress = 1 - Math.pow(1 - curveProgress, 3);
        
        drawGraph();
        
        if (curveProgress < 1) {
          animationFrame = requestAnimationFrame(animate);
        }
      }
      
      if (animationFrame) cancelAnimationFrame(animationFrame);
      animationFrame = requestAnimationFrame(animate);
    }

    function animateCorruption(point, toCorrupted) {
      const duration = 200;
      const startTime = performance.now();
      
      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(1, elapsed / duration);
        
        // Ease out
        const eased = 1 - Math.pow(1 - progress, 2);
        
        if (toCorrupted) {
          point.opacity = 1 - eased * 0.7;
        } else {
          point.opacity = 0.3 + eased * 0.7;
        }
        
        drawGraph();
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        }
      }
      
      requestAnimationFrame(animate);
    }

    canvas.addEventListener('click', (e) => {
      const canvasRect = canvas.getBoundingClientRect();
      const scaleX = rect.width / canvasRect.width;
      const scaleY = rect.height / canvasRect.height;
      const x = (e.clientX - canvasRect.left) * scaleX;
      const y = (e.clientY - canvasRect.top) * scaleY;
      
      [...dataPoints, ...checkPoints].forEach(point => {
        const px = 50 + point.x * 60;
        const py = 230 - point.y * 25;
        const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
        
        if (dist < 18) {
          point.corrupted = !point.corrupted;
          animateCorruption(point, point.corrupted);
          animateCurve();
        }
      });
    });

    // Redraw on theme change
    const observer = new MutationObserver(() => drawGraph());
    observer.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });

    // Initial animation
    setTimeout(() => {
      drawGraph();
      animateCurve();
    }, 100);

    // QR demo with polished buttons
    const originalSymbols = ['H', 'E', 'L', 'L', 'O'];
    const paritySymbols = ['K', 'R', '7', 'X'];
    let corrupted = new Array(9).fill(false);

    function createButtons() {
      const container = document.getElementById('corruption-buttons');
      container.innerHTML = '';
      
      [...originalSymbols, ...paritySymbols].forEach((sym, idx) => {
        const btn = document.createElement('button');
        btn.textContent = corrupted[idx] ? '�' : sym;
        btn.className = 'corrupt-btn';
        
        if (idx < 5) {
          btn.classList.add('data-point');
        } else {
          btn.classList.add('parity-point');
        }
        
        if (corrupted[idx]) {
          btn.classList.add('corrupted');
        }
        
        btn.onclick = () => toggleCorruption(idx);
        container.appendChild(btn);
      });
    }

    function toggleCorruption(idx) {
      corrupted[idx] = !corrupted[idx];
      createButtons();
      updateStatus();
    }

    function updateStatus() {
      const status = document.getElementById('status');
      const statusBox = document.getElementById('status-box');
      const errorCount = corrupted.filter(c => c).length;
      
      statusBox.classList.remove('status-recoverable');
      
      if (errorCount === 0) {
        status.innerHTML = 'All symbols intact. Message can be read directly.';
      } else if (errorCount <= 2) {
        status.innerHTML = `${errorCount} symbol${errorCount > 1 ? 's' : ''} corrupted. <strong>Message can be recovered</strong> using parity symbols.`;
        statusBox.classList.add('status-recoverable');
      } else {
        status.innerHTML = `${errorCount} symbols corrupted. <strong>Too many errors</strong> — message is unrecoverable.`;
      }
    }

    createButtons();
    updateStatus();
  </script>
</body>
</html>
